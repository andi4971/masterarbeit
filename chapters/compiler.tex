\chapter{MiniC++ Compiler}

This chapter describes the implementation of the compiler executable and its functionality. Further, exemplary MiniC\verb|++| source code is compiled, and the results are shown. 

\section{Application}

The MiniC\verb|++| compiler source code is structured so that every concern is separated into its own module. Overall the compiler is structured into the following modules:

\begin{itemize}
    \item ast
    \item ast-generator
    \item atg-parser
    \item barebone-parser
    \item bytecode-generator
    \item minicpp-console
    \item parser
    \item sourcecode-generator
\end{itemize}

The \verb|ast-generator| module provides functions to generate the AST using the listener-pattern, the visitor-pattern and via an attributed grammar. The \verb|atg-parser|, \verb|barebone-parser| and \verb|parser| each contain an implementation of the combined lexer and parser generated by ANTLR. While the \verb|atg-parser| module houses the attributed grammar implementation, the difference between the \verb|barebone-parser| and \verb|parser| module is more subtle. The \verb|barebone-parser| module contains an implementation of the combined lexer and parser that without any code for listeners or visitors. This module allows checking how long just the parsing process takes, without any other operations being performed. The \verb|minicpp-console| module, contains the implementation of the console application that encapsulates the functionality of the entire compiler. 

The console application accepts the following input parameters:

\begin{itemize}
    \item \verb|-v|, \verb|-visitor|: Performs the generation of the AST using the visitor-pattern implementation. This option is set per default.
    \item \verb|-l|, \verb|-listener|: Performs the generation of the AST using the listener-pattern implementation.
    \item \verb|-a|, \verb|-atg|: Performs the generation of the AST using the attributed grammar implementation.
    \item \verb|-s|, \verb|-source|: Additionally generates the source code from the AST. 
    \item \verb|-h|, \verb|-help|: Prints information about all available arguments.
\end{itemize}

The last input parameter is the filename of the MiniC\verb|++| source code file. The application then reads this file and produces a \verb|.class| file with the same filename. In case source code should also be generated, an additional file with the suffix \verb|_generated| is created.

The application is available as a \verb|jar| file and can be executed using the \verb|java -jar| command. A compilation of the file \verb|test.mcpp| using the listener implementation can be performed with the following command: \verb|java -jar compiler.jar -l test.mcpp|.

\section{Test Cases}

To ensure the compiler's functionality and correctness tests are conducted on different aspects of the bytecode generation. For each aspect, the MiniC\verb|++| source code is shown. The source code then gets compiled and the resulting bytecode is shown. The bytecode is presented using the \verb|javap| tool, that enables inspecting of a \verb|class| file's bytecode. If applicable, the console output is shown as well.    


\subsection{Hello World}

The first test shown in listing \ref{lst:TestHlWSrc} is a simple \textit{Hello World} application. Listing \ref{lst:TestHlWBtc} shows the generated bytecode. The class contains two methods. First, the \verb|main| method defined in the source code, which also contains the output statement for the \textit{Hello World} string. The string is printed onto the console by loading the \verb|PrintStream| and then the string literal onto the stack, and calling the \verb|print| method with the \verb|INVOKEVIRTUAL| opcode. The second \verb|main| method accepts a string array as the input parameter and is therefore the entry point into the application. Its only task is to invoke the parameterless main method defined in the MiniC\verb|++| source code. Executing the application produces the console output seen in listing \ref{lst:TestHlWCons}. The successful execution further shows that all runtime checks of the bytecode by the JVM completed without errors.

\begin{CppCode}[float,numbers=none,caption=MiniC\texttt{++} source code of a \textit{Hello World} application., label=lst:TestHlWSrc]
void main() {
    cout << "Hello World";
}    
\end{CppCode}


\begin{GenericCode}[float,numbers=none,caption=Bytecode of a \textit{Hello World} application., label=lst:TestHlWBtc]
public class Main {
    public static void main();
      Code:
         0: getstatic     #12   // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #14   // String Hello World
         5: invokevirtual #20   // Method java/io/PrintStream.print:(Ljava/lang/String;)V
         8: return
  
    public static void main(java.lang.String[]);
      Code:
         0: invokestatic  #38   // Method main:()V
         3: return
  }
\end{GenericCode}

\begin{GenericCode}[float,numbers=none,caption=Console output of a \textit{Hello World} application., label=lst:TestHlWCons]
Hello World
\end{GenericCode}


\subsection{Methods}

This test concerns with the usage of functions (methods in the JVM) and their return values. Listing \ref{lst:TestFuncSrc} shows the source code for an application that compares two booleans and prints the result. The \verb|bothTrue| function takes two booleans as an input, compares them, and returns the result. The \verb|printFormatted| function takes a boolean and prints its value. The \verb|main| function calls the \verb|printFormatted| function and its input value is provided by the \verb|bothTrue| function.

\begin{CppCode}[float,numbers=none,caption=MiniC\texttt{++} source code of a application with functions., label=lst:TestFuncSrc]
void printFormatted(bool value) {
    cout<< "Boolean result is: " << value;
}

bool bothTrue(bool left, bool right) {
    return left && right;
}

void main() {
 printFormatted(bothTrue(false, true));
} 
\end{CppCode}


The generated bytecode is shown in listing \ref{lst:TestFuncBtc}. The \verb|main| method first loads both boolean values and then calls the \verb|bothTrue| method. Its return value is put onto the stack and used as the input parameter for the \verb|printFormatted| method. The \verb|bothTrue| method performs short-circuit evaluation of the two boolean input parameters. The \verb|ifeq| opcode will cause a jump to instruction number 12 in case the value is \verb|false|. This instruction loads the constant 0 and the following one will return it. The \verb|printFormatted| method accepts the boolean value and proceeds to perform two invocations of the \verb|PrintStream.print| method. For the first invocation it loads the \verb|PrintStream| followed by the string literal to be displayed on the console. For the second invocation it loads the variable with index 0, which is the input boolean parameter. It then invokes the \verb|print| method which takes a boolean as a parameter, as can be seen from the descriptor of the \verb|print| method. Executing this program yields the console output shown in listing \ref{lst:TestFncCons}. Because the parameters used to invoke the \verb|bothTrue| method are not both \verb|true|, the console output displays \verb|false|.


\begin{GenericCode}[float,numbers=none,caption=Bytecode of the application with functions., label=lst:TestFuncBtc]
public class Main {
  
    public static void printFormatted(boolean);
      Code:
         0: getstatic     #12  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #14  // String Boolean result is:
         5: invokevirtual #20  // Method java/io/PrintStream.print:(Ljava/lang/String;)V
         8: getstatic     #12  // Field java/lang/System.out:Ljava/io/PrintStream;
        11: iload_0
        12: invokevirtual #22  // Method java/io/PrintStream.print:(Z)V
        15: return
  
    public static boolean bothTrue(boolean, boolean);
      Code:
         0: iload_0
         1: ifeq          12
         4: iload_1
         5: ifeq          12
         8: iconst_1
         9: goto          13
        12: iconst_0
        13: ireturn
        14: athrow
  
    public static void main();
      Code:
         0: ldc           #29  // int 0
         2: ldc           #30  // int 1
         4: invokestatic  #32  // Method bothTrue:(ZZ)Z
         7: invokestatic  #34  // Method printFormatted:(Z)V
        10: return
  
    public static void main(java.lang.String[]);
      Code:
         0: invokestatic  #52  // Method main:()V
         3: return
}
\end{GenericCode}


\begin{GenericCode}[float,numbers=none,caption=Console output of the application with functions., label=lst:TestFncCons]
Boolean result is: false
\end{GenericCode}

\subsection{Variables}

In this test the bytecode generation for variables is highlighted. Listing \ref{lst:TestVarSrc} shows source code where multiple variables are initialized and values are assigned to them. The generated bytecode is shown in listing \ref{lst:TestVarBtc}.  The \verb|loc_a| variable is transformed into an entry in the constant pool and does therefore not take up an entry in the local variables. Both arrays are first initialized with \verb|null| and then are initialized with the length being obtained by the \verb|arr_size| static variable. For the \verb|barr| field the value of the \verb|falser| constant is loaded. For this the value is loaded from the constant pool. The other static variable is the \verb|scanner| which is used for input from the console. Along with the \verb|arr_size| variable, both are initialized in the static initializer block of the class.  

\begin{CppCode}[float,numbers=none,caption=MiniC\texttt{++} source code of a application with variables., label=lst:TestVarSrc]
const bool falser = false;
int arr_size = 35;

void main() {
    const int loc_a = 10;
    bool loc_b = true;
    int * iarr = nullptr;
    bool * barr = nullptr;
    iarr = new int[arr_size];
    barr = new int[arr_size];
    iarr[5] = loc_a;
    barr[2] = falser;
}
\end{CppCode}

\begin{GenericCode}[float,numbers=none,caption=Bytecode of the application with variables., label=lst:TestVarBtc]
public class Main {
    public static int arr_size;
    public static java.util.Scanner scanner;
  
    public static void main();
      Code:
         0: ldc           #10  // int 1
         2: istore_1
         3: aconst_null
         4: astore_2
         5: aconst_null
         6: astore_3
         7: getstatic     #12  // Field arr_size:I
        10: newarray       int
        12: astore_2
        13: getstatic     #12  // Field arr_size:I
        16: newarray       int
        18: astore_3
        19: aload_2
        20: ldc           #13  // int 5
        22: ldc           #14  // int 10
        24: iastore
        25: aload_3
        26: ldc           #15  // int 2
        28: ldc           #5   // int 0
        30: bastore
        31: return
  
    static {};
      Code:
         0: ldc           #17  // int 35
         2: putstatic     #12  // Field arr_size:I
         5: new           #19  // class java/util/Scanner
         8: dup
         9: getstatic     #25  // Field java/lang/System.in:Ljava/io/InputStream;
        12: invokespecial #29  // Method java/util/Scanner."<init>":(Ljava/io/InputStream;)V
        15: putstatic     #33  // Field scanner:Ljava/util/Scanner;
        18: return
  
    public static void main(java.lang.String[]);
      Code:
         0: invokestatic  #36  // Method main:()V
         3: return
  }
    \end{GenericCode}



\subsection{While Loop}

This test targets while loops in bytecode by calculating factorials. The source code is shown in listing \ref{lst:TestWhileSrc}. The \verb|factorial| function calculates the factorial of a given number \verb|n| and returns the result. The compiler generates the following bytecode shown in listing \ref{lst:TestWhileBtc}. The \verb|factorial| method first initializes the required variables and then proceeds to perform the first condition check of the loop with the \verb|IF_ICMPGT| opcode. In case a jump is performed, another check is executed to determine if the current top value on the stack is \verb|true| or \verb|false|. When the execution proceeds without a jump, the \verb|while| statement's body is executed. The \verb|GOTO| opcode to instruction number six causes another check of the \verb|while| statement's condition. 


Executing the program calculates the factorial for the number 10. The result is printed on the console and shows the value \verb|3628800|. 

\begin{CppCode}[float,numbers=none,caption=MiniC\texttt{++} source code to calculate factorial with a \texttt{while} loop., label=lst:TestWhileSrc]
  int factorial(int n)
  {
    int res = 1;
    int i = 2;
    while(i <= n)
    {
       res *= i;
       i++;
    }       
      return res;
  }
  
  void main() {
    cout << factorial(10);
  }
  \end{CppCode}

\begin{GenericCode}[float,numbers=none,caption=Bytecode to calculate factorial with a \texttt{while} loop., label=lst:TestWhileBtc]
public class Main {

  public static int factorial(int);
    Code:
       0: ldc           #7  // int 1
       2: istore_1
       3: ldc           #8  // int 2
       5: istore_2
       6: iload_2
       7: iload_0
       8: if_icmpgt     15
      11: iconst_1
      12: goto          16
      15: iconst_0
      16: ifeq          29
      19: iload_1
      20: iload_2
      21: imul
      22: istore_1
      23: iinc          2, 1
      26: goto          6
      29: iload_1
      30: ireturn
      31: athrow

  public static void main();
    Code:
       0: getstatic     #18  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #19  // int 10
       5: invokestatic  #21  // Method factorial:(I)I
       8: invokevirtual #27  // Method java/io/PrintStream.print:(I)V
      11: return
}
\end{GenericCode}
    

%\begin{GenericCode}[float,numbers=none,caption=Console output of the factorial %application for the number 10., label=lst:TestWhileCons]
%3628800
%\end{GenericCode}