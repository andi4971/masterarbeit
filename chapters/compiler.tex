\chapter{MiniC++ Compiler}

This chapter describes the implementation of the compiler executable and its functionality. Further, exemplary MiniC\verb|++| source code is compiled, and the results are shown. 

\section{Application}

The MiniC\verb|++| compiler source code is structured so that every concern is separated into its own module. Overall the compiler is structured into the following modules:

\begin{itemize}
    \item ast
    \item ast-generator
    \item atg-parser
    \item barebone-parser
    \item bytecode-generator
    \item minicpp-console
    \item parser
    \item sourcecode-generator
\end{itemize}

The \verb|ast-generator| module provides functions to generate the AST using the listener-pattern, the visitor-pattern and via an attributed grammar. The \verb|atg-parser|, \verb|barebone-parser| and \verb|parser| each contain an implementation of the combined lexer and parser generated by ANTLR. While the \verb|atg-parser| module houses the attributed grammar implementation, the difference between the \verb|barebone-parser| and \verb|parser| module is more subtle. The \verb|barebone-parser| module contains an implementation of the combined lexer and parser that without any code for listeners or visitors. This module allows checking how long just the parsing process takes, without any other operations being performed. The \verb|minicpp-console| module, contains the implementation of the console application that encapsulates the functionality of the entire compiler. 

The console application accepts the following input parameters:

\begin{itemize}
    \item \verb|-v|, \verb|-visitor|: Performs the generation of the AST using the visitor-pattern implementation. This option is set per default.
    \item \verb|-l|, \verb|-listener|: Performs the generation of the AST using the listener-pattern implementation.
    \item \verb|-a|, \verb|-atg|: Performs the generation of the AST using the attributed grammar implementation.
    \item \verb|-s|, \verb|-source|: Additionally generates the source code from the AST. 
    \item \verb|-h|, \verb|-help|: Prints information about all available arguments.
\end{itemize}

The last input parameter is the filename of the MiniC\verb|++| source code file. The application then reads this file and produces a \verb|.class| file with the same filename. In case source code should also be generated, an additional file with the suffix \verb|_generated| is created.

The application is available as a \verb|jar| file and can be executed using the \verb|java -jar| command. A compilation of the file \verb|test.mcpp| using the listener implementation can be performed with the following command: \verb|java -jar compiler.jar -l test.mcpp|.

\section{Test Cases}

To ensure the compiler's functionality and correctness tests are conducted on different aspects of the bytecode generation. For each aspect, the MiniC\verb|++| source code is shown. The source code then gets compiled and the resulting bytecode is shown. The bytecode is presented using the \verb|javap| tool, that enables inspecting of a \verb|class| file's bytecode. If applicable, the console output is shown as well.    


\subsection{Hello World}

The first test shown in listing \ref{lst:TestHlWSrc} is a simple \textit{Hello World} application. Listing \ref{lst:TestHlWBtc} shows the generated bytecode. The class contains two methods. First, the \verb|main| method defined in the source code, which also contains the output statement for the \textit{Hello World} string. The string is printed onto the console by loading the \verb|PrintStream| and then the string literal onto the stack, and calling the \verb|print| method with the \verb|INVOKEVIRTUAL| opcode. The second \verb|main| method accepts a string array as the input parameter and is therefore the entry point into the application. Its only task is to invoke the parameterless main method defined in the MiniC\verb|++| source code. Executing the application produces the console output seen in listing \ref{lst:TestHlWCons}. The successful execution further shows that all runtime checks of the bytecode by the JVM completed without errors.

\begin{CppCode}[float,numbers=none,caption=MiniC\texttt{++} source code of a \textit{Hello World} application., label=lst:TestHlWSrc]
void main() {
    cout << "Hello World";
}    
\end{CppCode}


\begin{GenericCode}[float,numbers=none,caption=Bytecode of a \textit{Hello World} application., label=lst:TestHlWBtc]
public class Main {
    public static void main();
      Code:
         0: getstatic     #12   // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #14   // String Hello World
         5: invokevirtual #20   // Method java/io/PrintStream.print:(Ljava/lang/String;)V
         8: return
  
    public static void main(java.lang.String[]);
      Code:
         0: invokestatic  #38   // Method main:()V
         3: return
  }
\end{GenericCode}

\begin{GenericCode}[float,numbers=none,caption=Console output of a \textit{Hello World} application., label=lst:TestHlWCons]
Hello World
\end{GenericCode}


\subsection{Methods}

This test concerns with the usage of functions (methods in the JVM) and their return values. Listing \ref{lst:TestFuncSrc} shows the source code for an application that compares two booleans and prints the result. The \verb|bothTrue| function takes two booleans as an input, compares them, and returns the result. The \verb|printFormatted| function takes a boolean and prints its value. The \verb|main| function calls the \verb|printFormatted| function and its input value is provided by the \verb|bothTrue| function.

\begin{CppCode}[float,numbers=none,caption=MiniC\texttt{++} source code of a application with functions., label=lst:TestFuncSrc]
void printFormatted(bool value) {
    cout<< "Boolean result is: " << value;
}

bool bothTrue(bool left, bool right) {
    return left && right;
}

void main() {
 printFormatted(bothTrue(false, true));
} 
\end{CppCode}


The generated bytecode is shown in listing \ref{lst:TestFuncBtc}. The \verb|main| method first loads both boolean values and then calls the \verb|bothTrue| method. Its return value is put onto the stack and used as the input parameter for the \verb|printFormatted| method. The \verb|bothTrue| method 


\begin{GenericCode}[float,numbers=none,caption=Bytecode of the application with functions., label=lst:TestFuncBtc]
public class Main {
  
    public static void printFormatted(boolean);
      Code:
         0: getstatic     #12  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #14  // String Boolean result is:
         5: invokevirtual #20  // Method java/io/PrintStream.print:(Ljava/lang/String;)V
         8: getstatic     #12  // Field java/lang/System.out:Ljava/io/PrintStream;
        11: iload_0
        12: invokevirtual #22  // Method java/io/PrintStream.print:(Z)V
        15: return
  
    public static boolean bothTrue(boolean, boolean);
      Code:
         0: iload_0
         1: ifeq          12
         4: iload_1
         5: ifeq          12
         8: iconst_1
         9: goto          13
        12: iconst_0
        13: ireturn
        14: athrow
  
    public static void main();
      Code:
         0: ldc           #29  // int 0
         2: ldc           #30  // int 1
         4: invokestatic  #32  // Method bothTrue:(ZZ)Z
         7: invokestatic  #34  // Method printFormatted:(Z)V
        10: return
  
    public static void main(java.lang.String[]);
      Code:
         0: invokestatic  #52  // Method main:()V
         3: return
}
\end{GenericCode}




\subsection{Variables}

\subsection{Statement}

\subsection{Expressions}