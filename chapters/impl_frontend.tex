\chapter{Implementation Frontend}

This chapter explains the implementation of the frontend of the compiler. First the additional technologies that are used in the development of the frontend are listed. Then the AST and symboltable are explained. In the following section the ANTLR grammar is shown. Based on this grammar three implementations for the AST transformation are explained: Visitor-pattern, listener-pattern and via an attributed grammar. 

\section{Used Technologies}

In this section the additional technologies used for the development of the frontend are explained. This includes chosen the programming language and the additional libraries used.

\subsection{Kotlin}

For the implementation the programming language Kotlin is chosen. Kotlin can be compiled to bytecode, which makes it possible to use Java libraries in Kotlin code. Kotlin has advantages over Java in some aspects. For example, null safety\footnote{https://kotlinlang.org/docs/null-safety.html} is implemented into the language via explicit nullability within it's type system. This requires the caller of a field to explicitly handle nullable fields and thus reduces the risk of a null reference exception. 

\subsection{AspectJ}

The compiler frontend utilizes AspectJ in it's handling of semantic errors. AspectJ is a library that enables aspect oriented programming in Java. Aspect oriented programming makes it possible to handle cross-cutting concerns in a central place without having to modify code in other areas. It can be used for compile time and runtime weaving of cross-cutting concerns. In the compiler frontend, runtime weaving using annotations is used.  

\subsection{ANTLR Preview Plugin}

During development with the JetBrains IntelliJ IDE, the ANTLR preview plugin\footnote{https://plugins.jetbrains.com/plugin/7358-antlr-v4} is used. The plugin developed by the ANTLR creator Terrance Parr, offers various features that enhance the process of creating and working with ANTLR. When developing an ANTLR grammar, syntax highlighting and checking for syntactic and semantic errors is provided. The included navigation window inside the IDE further enables testing of the grammar, without having to generate the combined lexer and parser manually first. To generate the combined lexer and parser the plugin includes a tool window which includes common configuration settings.

\section{ANTLR Grammar}

The ANTLR grammar is based on the MiniC++ grammar in EBNF-form. This grammar is transformed into the ANTLR grammar syntax. ANTLR grammars are stored inside \texttt{.g4} files. Each rule inside the grammar is delimited by a semicolon. 

\subsection{Header Section}

At the top of the grammar file, the name of the grammar is specified. In this case \texttt{minicpp}. In this section options can also be specified, like the implementation language of the lexer and parser or the package/namespace of the generated code. These and other options can also be specified via command line options during the generation. In this case the necessary options are specified in the tool window of the ANTLR preview plugin. 

%if in need add picture of tool window

\subsection{Terminal Classes and Comments}

The grammar contains three terminal classes shown in listing \ref{lst:ANTLRMiniCppTermClass}. The \texttt{IDENT} terminal class is used for all identifiers and requires them to start with a letter followed by an arbitrary number of letters and digits. For integer number the \texttt{INT} terminal class specifies a sequence of one or more digits. Signs are handled in the parser rules. Strings are defined as a sequence of characters starting and ending with double quotes. All characters except the special characters for line end are allowed. The comment and whitespace handling is performed by the \texttt{WS}, \verb|LINE_COMMENT| and \verb|BLOCK_COMMENT| lexical rules. These are special rules that when matched tell the parser to skip them and therefore not include them in the syntax tree. 

\begin{AntlrCode}[float,numbers=none,caption=Terminal classes of the MiniC++ ANTLR grammar., label=lst:ANTLRMiniCppTermClass]
IDENT:          [a-zA-Z_][a-zA-Z_0-9]*;
INT:            [0-9]+;
STRING:         '"' (~[\r\n"] | '""')* '"';
WS:             [ \t\n\r]+ -> skip;
LINE_COMMENT:   '//' ~[\r\n]* -> skip;
BLOCK_COMMENT:  '/*' .*? '*/' -> skip;
\end{AntlrCode}


\subsection{Root}

The top rules of the grammar are shown in listing \ref{lst:ANTLRMiniCppTop}. The root rule \texttt{miniCpp} contains zero or more elements of the rule \texttt{miniCppEntry} followed by the lexical rule \texttt{EOF}. \texttt{EOF} is a default lexical rule provided by ANTLR signaling the end of the file. \texttt{miniCppEntry} defines the elements that can be used at the top level of the miniC\verb|++| source file. These are variable and constant definitions and function declarations and definitions. \texttt{SEM} is the lexical rule defining a semicolon. 

\begin{AntlrCode}[float,numbers=none,caption=Top rules of the MiniC++ ANTLR grammar., label=lst:ANTLRMiniCppTop]
miniCpp:     (miniCppEntry)* EOF;
miniCppEntry:     constDef
                | varDef
                | funcDecl
                | funcDef
                | SEM
                ;
\end{AntlrCode}



\subsection{Variables and Constants}

Listing \ref{lst:ANTLRMiniCppVarConstDef} shows the parser rules variable and constant definitions. Both definitions can have multiple entries, which are separated by a comma. In the case of a constant definition entry, the initialization value is required. For a variable this is optional. The \texttt{STAR} optional lexical rule classifies a field as an array if present. The \texttt{initOption} parser rule consists of three production alternatives specifying the possible initialization values. 

\begin{AntlrCode}[float,numbers=none,caption=Variable and constant defintions of the MiniC++ ANTLR grammar., label=lst:ANTLRMiniCppVarConstDef]
constDef:        CONST type constDefEntry (COMMA constDefEntry)* SEM ;
constDefEntry:   IDENT init ;

varDef:          type varDefEntry (COMMA varDefEntry)* SEM ;
varDefEntry:     STAR? IDENT (init)? ;

init:            EQUAL  initOption ;
initOption:      BOOLEAN      #BooleanInit
               | NULLPTR      #NullptrInit
               | (SIGN)? INT  #IntInit
               ;
\end{AntlrCode}

\subsection{Function Declaration and Implementation}

\begin{AntlrCode}[float,numbers=none,caption=Function declaration and defintion of the MiniC++ ANTLR grammar., label=lst:ANTLRMiniCppFuncDeclDef]
funcDecl:         funcHead SEM;
funcDef:          funcHead block;
funcHead:         type STAR? IDENT LPAREN formParList? RPAREN;
formParList:      (VOID
                  |     formParListEntry
                   (COMMA formParListEntry)*
                  );
formParListEntry: type STAR? IDENT (BRACKETS)?;
\end{AntlrCode}


\subsection{Statements}

\subsection{Expressions}